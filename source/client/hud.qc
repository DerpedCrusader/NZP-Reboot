//*********************************************************************/
//							HUD Drawing Code						   /
//																	   /
//*********************************************************************/			


/*******************
*    HUD_Health   *
*******************/

void(float width, float height) HUD_Health = 
{
	local float health;	
	float alpha;
	
	health = getstatf(STAT_HEALTH); 

	if (health < 100)
	{
		alpha = (100.0 - ((1.25 * health) - 25))/100*255;
		if (alpha <= 0.0)
			return;
		float modifier = (sin(time * 10) * 20) - 20;//always negative
		if(modifier < -35.0)
		modifier = -35.0;
    
		alpha += modifier;
    
		if(alpha < 0.0)
			return;
		float color = 255.0 + modifier;
    
		drawpic([0,0,0], "gfx/hud/blood.tga", [width, height, 0], [10,0,0], alpha/2000); // naievil -- alpha factor division here makes it easy to use legacy code
	}
	
}

/*******************
*    HUD_Ammo      *
*******************/

void(float width, float height) HUD_Ammo =
{
	local float ammo, curmag, benis, benis2;
	string ammostring, ammostring_1, ammostring_2;
	vector color;
	
	curmag = getstatf(STAT_CURRENTMAG);		
	ammo = getstatf(STAT_AMMO);	
	
	benis = strlen(ftos(ammo));
	benis2 = strlen(ftos(curmag));
	benis = benis + benis2;
	
	if (GetLowAmmo(getstatf(STAT_ACTIVEWEAPON), 1) >= getstatf(STAT_CURRENTMAG))
		color = [215/255, 0, 0];
	else
		color = [1, 1, 1];
	
	if (GetLowAmmo(getstatf(STAT_ACTIVEWEAPON), 0) >= getstatf(STAT_AMMO))
		vector color_2 = [215/255, 0, 0];
	else
		color_2 = [1, 1, 1];


	if (IsDualWeapon(getstatf(STAT_ACTIVEWEAPON))) {
		float curmag2 = getstatf(STAT_CURRENTMAG2);
		
		ammostring = strcat(ftos(curmag2), " ", ftos(curmag), "/", ftos(ammo));
		drawstring([width - (42/480)*width - (benis*20*width/1024), 0.96*height, 0], ammostring, [0.02*width, 0.02*width, 0], [1,1,1], 1, 1);
	} else {
		ammostring_1 = ftos(curmag);
		ammostring_2 = strcat("/",ftos(ammo));
		drawstring([width - (42/480)*width - (benis*20*width/1024), 0.96*height, 0], ammostring_1, [0.02*width, 0.02*width, 0], color, 1, 1);
		drawstring([width - (42/480)*width - ((benis-strlen(ftos(curmag)))*20*width/1024), 0.96*height, 0], ammostring_2, [0.02*width, 0.02*width, 0], color_2, 1, 1);
	}
}

void() HUD_AmmoString =
{
	vector textcolor = [1, 1, 1];
	string message = "";
	
	if (GetLowAmmo(getstatf(STAT_ACTIVEWEAPON), 1) >= getstatf(STAT_CURRENTMAG) && getstatf(STAT_WEAPONZOOM) != 2)
	{
		if (0 < getstatf(STAT_AMMO) && getstatf(STAT_CURRENTMAG) >= 0) {
			message = "Reload";
			textcolor = [1, 1, 1];
		} else if (0 < getstatf(STAT_CURRENTMAG)) {
			message = "LOW AMMO";
			textcolor = [219/255, 203/255, 19/255];		
		} else {
			message = "NO AMMO";
			textcolor = [215/255, 0, 0];
		}
		drawstring([g_width/2, g_height/2 + (30/272)*g_height, 0], message, [0.02*g_width, 0.02*g_width, 0], textcolor, 1, 1);
	}
}

/*******************
*    HUD_Points    *
*******************/

void(float width, float height) HUD_Points =
{
	local float pointlength = 0, increm = 10, i = 0;
	vector TEXTCOLOR;
	
	for (i = 3; i >= 0; i = i - 1)
	{
		if (playerpoints[i] == -1)
			continue;
			
		switch(i) {
			case 1: TEXTCOLOR = TEXT_LIGHTBLUE; break;
			case 2: TEXTCOLOR = TEXT_ORANGE; break;
			case 3: TEXTCOLOR = TEXT_GREEN; break;
			default: TEXTCOLOR = [1, 1, 1]; break;
		}
		
		if ((i+1) == getstatf(STAT_PLAYERNUM)) {
			pointlength = strlen(ftos(playerpoints[i]));
			drawpic([0.8*width,0.70*height - (.061*height*i),0], "gfx/hud/moneyback.tga", [0.2*width, 0.07*height, 0], [1,1,1], 1); 
			drawstring([.9414*width - pointlength*20*width/1024, 0.715*height - 0.06*height*i, 0], ftos(playerpoints[i]), [0.022*width, 0.022*width, 0], TEXTCOLOR, 1, 1); 
		}
		else {
			pointlength = strlen(ftos(playerpoints[i]));
			drawpic([0.85*width,0.70*height - (.071*height*i*0.8),0], "gfx/hud/moneyback.tga", [0.2*width*0.8, 0.07*height*0.8, 0], [1,1,1], 1); 
			drawstring([.97*width - pointlength*20*width/1024, 0.715*height - 0.07*height*i*0.8, 0], ftos(playerpoints[i]), [0.022*width*0.8, 0.022*width*0.8, 0], TEXTCOLOR, 1, 1); 
		}
	}
}

/*******************
*    HUD_Grenades  *
*******************/

void(float width, float height) HUD_Grenades =
{
	local float grenades;
	local float betties;

	grenades = getstatf(STAT_GRENADES);
	betties = getstatf(STAT_SECGRENADES);
	drawpic([0.9*width,0.825*height,0], "gfx/hud/frag.tga", [50, 50, 0], [1,1,1], 1);
	drawstring([0.9*width + 28, 0.825*height + 32, 0], ftos(grenades), [0.025*width, 0.025*width, 0], [1, 1, 1], 1, 1);
	
	if (betties != -1) {
		drawpic([0.825*width,0.825*height,0], "gfx/hud/betty.tga", [50, 50, 0], [1,1,1], 1);
		drawstring([0.825*width + 28, 0.825*height + 32, 0], ftos(betties), [0.025*width, 0.025*width, 0], [1, 1, 1], 1, 1);
	}
}

/*******************
*    HUD_Rounds    *
*******************/

float 	color_shift[3];
float 	color_shift_end[3];
float 	color_shift_steps[3];
int		color_shift_init;
int 	blinking;
string sb_round[5];
string sb_round_num[10];
int alphabling;
float endroundchange;
float round_center_x;
float round_center_y;
//motolegacy -- 'round' text
float pwidth;
float rcolor, rinit, ralpha, localpha;

void(float width, float height) HUD_Rounds =
{	
	float roundheight = 48/272*height;
	float roundwidth = 0.02291666*width;
	
	float roundwidth_4 = (60/480)*width;
	float roundheight_4 = (48/272)*height;
	
	float roundheight_num = 48/272*height;
	float roundwidth_num = 48/480*height; // naievil -- was 32, but more square makes it look better

//	drawstring([0.01*width, 0.70*height, 0], ftos(rounds_change), [0.03*width, 0.03*width, 0], [1, 1, 1], 1, 1); // draw roundchange

	int i, x_offset, icon_num, savex;
	int num[3];
	x_offset = 0;
	savex = 0;
	
	sb_round[0] = "gfx/hud/r1.tga";
	sb_round[1] = "gfx/hud/r2.tga";
	sb_round[2] = "gfx/hud/r3.tga";
	sb_round[3] = "gfx/hud/r4.tga";
	sb_round[4] = "gfx/hud/r5.tga";
	
	sb_round_num[0] = "gfx/hud/r_num0.tga";
	sb_round_num[1] = "gfx/hud/r_num1.tga";
	sb_round_num[2] = "gfx/hud/r_num2.tga";
	sb_round_num[3] = "gfx/hud/r_num3.tga";
	sb_round_num[4] = "gfx/hud/r_num4.tga";
	sb_round_num[5] = "gfx/hud/r_num5.tga";
	sb_round_num[6] = "gfx/hud/r_num6.tga";
	sb_round_num[7] = "gfx/hud/r_num7.tga";
	sb_round_num[8] = "gfx/hud/r_num8.tga";
	sb_round_num[9] = "gfx/hud/r_num9.tga";

	if (rounds_change == 1 || rounds_change == 2) {
		if (!rinit) {
			rcolor = rinit = 1;
			ralpha = 1;
		}

		pwidth = (width - stringwidth("Round", 0, [0.030*width, 0.030*width, 0]))/2;
		drawstring([pwidth, 0.35*height, 0], "Round", [0.030*width, 0.030*width, 0], [1, rcolor, rcolor], ralpha, 1);

		rcolor -= 0.0008;
		if (rcolor < 0) {
			rcolor = 0;
			ralpha -= 0.0008;
			if (ralpha > 0) {
				localpha += 0.005;
				if (localpha > 1)
					localpha = 1;
			}
			if (ralpha < 0) {
				ralpha = 0;
				localpha -= 0.005;
				if (localpha < 0)
					localpha = 0;
			}
		}

		drawstring([0.01*width, 0.66*height, 0], chaptertitle, [0.015*width, 0.015*width, 0], [1, 1, 1], localpha, 1);
		drawstring([0.01*width, 0.69*height, 0], location, [0.015*width, 0.015*width, 0], [1, 1, 1], localpha, 1);
		drawstring([0.01*width, 0.72*height, 0], date, [0.015*width, 0.015*width, 0], [1, 1, 1], localpha, 1);
		drawstring([0.01*width, 0.75*height, 0], person, [0.015*width, 0.015*width, 0], [1, 1, 1], localpha, 1);
	}

	if (rounds_change == 1)//this is the rounds icon at the middle of the screen
	{
		alphabling = alphabling + 1;

		if (alphabling < 0)
			alphabling = 0;
		else if (alphabling > 255)
			alphabling = 255;
			
		round_center_x = (g_width - (11*g_width/480)) /2;
		round_center_y = (g_height - (48*g_height/272)) /2;
		
		drawpic([round_center_x,round_center_y,0], sb_round[0], [roundwidth, roundheight, 1], [107/255,1/255,0], alphabling/255);
	}
	else if (rounds_change == 2)//this is the rounds icon moving from middle
	{
		float round_center_y_offset, round_center_x_offset;
				
		drawpic([round_center_x + round_center_x_offset,round_center_y + round_center_y_offset,0], sb_round[0], [roundwidth,roundheight, 1], [107/255,(1/255),0], 1);
		
		round_center_x = round_center_x - (((229/108)*2 - 0.2)*(width/480)/8);
		round_center_y = round_center_y + ((2*(height/272))/8);
		if (round_center_x <= (5/480)*height)
			round_center_x = (5/480)*height;
		if (round_center_y >= (220/272)*height)
			round_center_y = (220/272)*height;
					
	}
	else if (rounds_change == 3)//shift to white
	{
		if (!color_shift_init)
		{
			color_shift[0] = 107;
			color_shift[1] = 1;
			color_shift[2] = 0;
			for (i = 0; i < 3; i = i + 1)
			{
				color_shift_end[i] = 255;
				color_shift_steps[i] = (color_shift_end[i] - color_shift[i])/60;
			}
			color_shift_init = 1;
		}
		for (i = 0; i < 3; i = i + 1)
		{
			if (color_shift[i] < color_shift_end[i])
				color_shift[i] = color_shift[i] + color_shift_steps[i];

			if (color_shift[i] >= color_shift_end[i])
				color_shift[i] = color_shift_end[i];
		}
		if (rounds > 0 && rounds < 11)
		{

			for (i = 0; i < rounds; i = i + 1)
			{
				if (i == 4)
				{
					drawpic([5,height - roundheight, 0], sb_round[4], [roundwidth_4,roundheight_4, 1], [color_shift[0]/255,color_shift[1]/255,color_shift[2]/255], 1);
					
					savex = x_offset + (10*width/480);
					x_offset = x_offset + (10*width/480);
					continue;
				}
				if (i == 9)
				{
					drawpic([5 + savex, height - roundheight - (4*height/272),0], sb_round[4], [roundwidth_4,roundheight_4, 1], [color_shift[0]/255,color_shift[1]/255,color_shift[2]/255], 1);
					continue;
				}
				if (i > 4)
					icon_num = i - 5;
				else
					icon_num = i;

				drawpic([5 + x_offset, height - roundheight - (4*height/272),0], sb_round[icon_num], [roundwidth,roundheight, 1], [color_shift[0]/255,color_shift[1]/255,color_shift[2]/255], 1);

				x_offset = x_offset +  roundwidth + (3*width/480);
			}
		}
		else
		{
			if (rounds >= 100)
			{
				num[2] = (int)(rounds/100);
				drawpic([5 + x_offset, height - roundheight - (4*height/272),0], sb_round_num[num[2]], [roundwidth_num, roundheight_num, 1], [color_shift[0]/255,color_shift[1]/255,color_shift[2]/255], 1);
								
				x_offset = x_offset +  roundwidth_num - (8*width/480);
			}
			else
				num[2] = 0;
			if (rounds >= 10)
			{
				num[1] = (int)((rounds - num[2]*100)/10);
				drawpic([5 + x_offset, height - roundheight - (4*height/272),0], sb_round_num[num[1]], [roundwidth_num,roundheight_num, 1], [color_shift[0]/255,color_shift[1]/255,color_shift[2]/255], 1);

				x_offset = x_offset +  roundwidth_num - (8*width/480);
			}
			else
				num[1] = 0;

			num[0] = rounds - num[2]*100 - num[1]*10;
			drawpic([5 + x_offset, height - roundheight - (4*height/272),0], sb_round_num[num[0]], [roundwidth_num,roundheight_num, 1], [color_shift[0]/255,color_shift[1]/255,color_shift[2]/255], 1);

			x_offset = x_offset +  roundwidth_num - (8*width/480);
		}
	}
	else if (rounds_change == 4)//blink white
	{
	
		if (endroundchange > time)
		{
			blinking = ((int)(time*1000)&510) - 255;
			blinking = fabs(blinking);
		}
		else
		{
			if (blinking)
				blinking = blinking - 1;
			else
				blinking = 0;
		}
			
	
		if (rounds > 0 && rounds < 11)
		{
			for (i = 0; i < rounds; i = i + 1)
			{
				if (i == 4)
				{
					drawpic([5, height - roundheight - (4*height/272),0], sb_round[4], [roundwidth_4,roundheight_4, 1], [1,1,1], blinking/255);

					savex = x_offset + (10*width/480);
					x_offset = x_offset + (10*width/480);
					continue;
				}
				if (i == 9)
				{
					drawpic([5 + savex, height - roundheight - (4*height/272),0], sb_round[4], [roundwidth_4,roundheight_4, 1], [1,1,1], blinking/255);

					continue;
				}
				if (i > 4)
					icon_num = i - 5;
				else
					icon_num = i;

					drawpic([5 + x_offset, height - roundheight - (4*height/272),0], sb_round[icon_num], [roundwidth,roundheight, 1], [1,1,1], blinking/255);

				x_offset = x_offset +  roundwidth + (3*width/480);
			}
		}
		else
		{
			if (rounds >= 100)
			{
				num[2] = (int)(rounds/100);
				drawpic([2 + x_offset, height - roundheight - (4*height/272),0], sb_round_num[num[2]], [roundwidth_num,roundheight_num, 1], [1,1,1], blinking/255);
					
				x_offset = x_offset +  roundwidth_num - (8*width/480);
			}
			else
				num[2] = 0;
			if (rounds >= 10)
			{
				num[1] = (int)((rounds - num[2]*100)/10);
				drawpic([2 + x_offset, height - roundheight - (4*height/272),0], sb_round_num[num[1]], [roundwidth_num,roundheight_num, 1], [1,1,1], blinking/255);
				
				x_offset = x_offset +  roundwidth_num - (8*width/480);
			}
			else
				num[1] = 0;

			num[0] = rounds - num[2]*100 - num[1]*10;
			drawpic([2 + x_offset, height - roundheight - (4*height/272),0], sb_round_num[num[0]], [roundwidth_num,roundheight_num, 1], [1,1,1], blinking/255);
			
			x_offset = x_offset +  roundwidth_num - (8*width/480);
		}
		
		if (endroundchange == 0)
			endroundchange = time + 2;
	}
	else if (rounds_change == 5)//blink white
	{
		if (blinking > 0)
			blinking = blinking - 10;
		if (blinking < 0)
			blinking = 0;
		if (rounds > 0 && rounds < 11)
		{
			for (i = 0; i < rounds; i = i + 1)
			{
				if (i == 4)
				{
					drawpic([5, height - roundheight - (4*height/272),0], sb_round[4], [roundwidth_4,roundheight_4, 1], [1,1,1], blinking/255);

					savex = x_offset + (10*width/480);
					x_offset = x_offset + (10*width/480);
					continue;
				}
				if (i == 9)
				{
					drawpic([5 + savex, height - roundheight - (4*height/272),0], sb_round[4], [roundwidth_4,roundheight_4, 1], [1,1,1], blinking/255);
					continue;
				}
				if (i > 4)
					icon_num = i - 5;
				else
					icon_num = i;

				drawpic([5 + x_offset, height - roundheight - (4*height/272),0], sb_round[icon_num], [roundwidth,roundheight, 1], [1,1,1], blinking/255);

				x_offset = x_offset +  roundwidth + (3*width/480);
			}
		}
		else
		{
			if (rounds >= 100)
			{
				num[2] = (int)(rounds/100);
				drawpic([2 + x_offset, height - roundheight - (4*height/272),0], sb_round_num[num[2]], [roundwidth_num,roundheight_num, 1], [1,1,1], blinking/255);

				x_offset = x_offset +  roundwidth_num - (8*width/480);
			}
			else
				num[2] = 0;
			if (rounds >= 10)
			{
				num[1] = (int)((rounds - num[2]*100)/10);
				drawpic([2 + x_offset, height - roundheight - (4*height/272),0], sb_round_num[num[1]], [roundwidth_num,roundheight_num, 1], [1,1,1], blinking/255);

				x_offset = x_offset +  roundwidth_num - (8*width/480);
			}
			else
				num[1] = 0;

			num[0] = rounds - num[2]*100 - num[1]*10;
			drawpic([2 + x_offset, height - roundheight - (4*height/272),0], sb_round_num[num[0]], [roundwidth_num,roundheight_num, 1], [1,1,1], blinking/255);

			x_offset = x_offset +  roundwidth_num - (8*width/480);
		}
	}
	else if (rounds_change == 6)//blink white while fading back
	{
		endroundchange = 0;
		
		color_shift_init = 0;
		blinking = ((int)(time*1000)&510) - 255;
		
		blinking = fabs(blinking);
			
		if (rounds > 0 && rounds < 11)
		{
			for (i = 0; i < rounds; i = i + 1)
			{
				if (i == 4)
				{
					drawpic([5, height - roundheight - (4*height/272),0], sb_round[4], [roundwidth_4,roundheight_4, 1], [1,1,1], blinking/255);
								
					savex = x_offset + (10*width/480);
					x_offset = x_offset + (10*width/480);
					continue;
				}
				if (i == 9)
				{
					drawpic([5 + savex, height - roundheight - (4*height/272),0], sb_round[4], [roundwidth_4,roundheight_4, 1], [1,1,1], blinking/255);

					continue;
				}
				if (i > 4)
					icon_num = i - 5;
				else
					icon_num = i;

				drawpic([5 + x_offset, height - roundheight - (4*height/272),0], sb_round[icon_num], [roundwidth,roundheight, 1], [1,1,1], blinking/255);

				x_offset = x_offset +  roundwidth + (3*width/480);
			}
		}
		else
		{
			if (rounds >= 100)
			{
				num[2] = (int)(rounds/100);
				drawpic([2 + x_offset, height - roundheight - (4*height/272),0], sb_round_num[num[2]], [roundwidth_num,roundheight_num, 1], [1,1,1], blinking/255);
				
				x_offset = x_offset +  roundwidth_num - (8*width/480);
			}
			else
				num[2] = 0;
			if (rounds >= 10)
			{
				num[1] = (int)((rounds - num[2]*100)/10);
				drawpic([2 + x_offset, height - roundheight - (4*height/272),0], sb_round_num[num[1]], [roundwidth_num,roundheight_num, 1], [1,1,1], blinking/255);

				x_offset = x_offset +  roundwidth_num - (8*width/480);
			}
			else
				num[1] = 0;

			num[0] = rounds - num[2]*100 - num[1]*10;
			drawpic([2 + x_offset, height - roundheight - (4*height/272),0], sb_round_num[num[0]], [roundwidth_num,roundheight_num, 1], [1,1,1], blinking/255);

			x_offset = x_offset +  roundwidth_num - (8*width/480);
		}
	}
	else if (rounds_change == 7)//blink white while fading back
	{
		if (!color_shift_init)
		{
			color_shift_end[0] = 107;
			color_shift_end[1] = 1;
			color_shift_end[2] = 0;
			for (i = 0; i < 3; i = i + 1)
			{
				color_shift[i] = 255;
				color_shift_steps[i] = (color_shift[i] - color_shift_end[i])/60;
			}
			color_shift_init = 1;
		}
		for (i = 0; i < 3; i = i + 1)
		{
			if (color_shift[i] > color_shift_end[i])
				color_shift[i] = color_shift[i] - color_shift_steps[i];

			if (color_shift[i] < color_shift_end[i])
				color_shift[i] = color_shift_end[i];
		}
		if (rounds > 0 && rounds < 11)
		{
			for (i = 0; i < rounds; i = i + 1)
			{
				if (i == 4)
				{
					drawpic([5, height - roundheight - (4*height/272),0], sb_round[4], [roundwidth_4,roundheight_4, 1], [color_shift[0]/255,color_shift[1]/255,color_shift[2]/255], 1);

					savex = x_offset + (10*width/480);
					x_offset = x_offset + (10*width/480);
					continue;
				}
				if (i == 9)
				{
					drawpic([5 + savex, height - roundheight - (4*height/272),0], sb_round[4], [roundwidth_4,roundheight_4, 1], [color_shift[0]/255,color_shift[1]/255,color_shift[2]/255], 1);

					continue;
				}
				if (i > 4)
					icon_num = i - 5;
				else
					icon_num = i;

				drawpic([5 + x_offset, height - roundheight - (4*height/272),0], sb_round[icon_num], [roundwidth,roundheight, 1], [color_shift[0]/255,color_shift[1]/255,color_shift[2]/255], 1);

				x_offset = x_offset +  roundwidth + (3*width/480);
			}
		}
		else
		{
			if (rounds >= 100)
			{
				num[2] = (int)(rounds/100);
				drawpic([2+x_offset, height - roundheight - (4*height/272),0], sb_round_num[num[2]], [roundwidth_num,roundheight_num, 1], [color_shift[0]/255,color_shift[1]/255,color_shift[2]/255], 1);

				x_offset = x_offset +  roundwidth_num - (8*width/480);
			}
			else
				num[2] = 0;
			if (rounds >= 10)
			{
				num[1] = (int)((rounds - num[2]*100)/10);
				drawpic([2+x_offset, height - roundheight - (4*height/272),0], sb_round_num[num[1]], [roundwidth_num,roundheight_num, 1], [color_shift[0]/255,color_shift[1]/255,color_shift[2]/255], 1);

				x_offset = x_offset +  roundwidth_num - (8*width/480);
			}
			else
				num[1] = 0;

			num[0] = rounds - num[2]*100 - num[1]*10;
			drawpic([2+x_offset, height - roundheight - (4*height/272),0], sb_round_num[num[0]], [roundwidth_num,roundheight_num, 1], [color_shift[0]/255,color_shift[1]/255,color_shift[2]/255], 1);

			x_offset = x_offset +  roundwidth_num - (8*width/480);
		}
	}
	else
	{
		color_shift[0] = 107;
		color_shift[1] = 1;
		color_shift[2] = 0;
		color_shift_init = 0;
		alphabling = 0;
		if (rounds > 0 && rounds < 11)
		{
			for (i = 0; i < rounds; i = i + 1)
			{
				if (i == 4)
				{
					drawpic([5, height - roundheight - (4*height/272),0], sb_round[4], [roundwidth_4,roundheight_4, 1], [107/255,1/255,0], 1);

					savex = x_offset + (10*width/480);
					x_offset = x_offset + (10*width/480);
					continue;
				}
				if (i == 9)
				{
					drawpic([5 + savex, height - roundheight - (4*height/272),0], sb_round[4], [roundwidth_4,roundheight_4, 1], [107/255,1/255,0], 1);

					continue;
				}
				if (i > 4)
					icon_num = i - 5;
				else
					icon_num = i;

				drawpic([5 + x_offset, height - roundheight - (4*height/272),0], sb_round[icon_num], [roundwidth,roundheight, 1], [107/255,1/255,0], 1);

				x_offset = x_offset +  roundwidth + (3*width/480);
			}
		}
		else
		{
			if (rounds >= 100)
			{
				num[2] = (int)(rounds/100);
				drawpic([2 + x_offset, height - roundheight - (4*height/272),0], sb_round_num[num[2]], [roundwidth_num,roundheight_num, 1], [107/255,1/255,0], 1);

				x_offset = x_offset +  roundwidth_num - (8*width/480);
			}
			else
				num[2] = 0;
			if (rounds >= 10)
			{
				num[1] = (int)((rounds - num[2]*100)/10);
				drawpic([2 + x_offset, height - roundheight - (4*height/272),0], sb_round_num[num[1]], [roundwidth_num,roundheight_num, 1], [107/255,1/255,0], 1);

				x_offset = x_offset +  roundwidth_num - (8*width/480);
			}
			else
				num[1] = 0;

			num[0] = rounds - num[2]*100 - num[1]*10;
			
			if(rounds == 0)
				return;
			
			drawpic([2 + x_offset, height - roundheight - (4*height/272),0], sb_round_num[num[0]], [roundwidth_num,roundheight_num, 1], [107/255,1/255,0], 1);

			x_offset = x_offset +  roundwidth_num - (8*width/480);
		}
	}
}

/*******************
*    HUD_Useprint  *
*******************/

void(float width, float height) HUD_Useprint =
{

		string usestring, usebutton;
		float print_width, x;
		
		tokenize(findkeysforcommand("+button7"));
		usebutton = strtoupper(keynumtostring(stof(argv(0))));

		switch (useprint_type) {
			case 0://clear
				usestring = "";
				break;
			case 1://door
				usestring = strcat("Hold ",usebutton, " to open door [Cost:", ftos(useprint_cost),"]");
				break;
			case 2://debris
				usestring = strcat("Hold ",usebutton, " to remove debris [Cost:", ftos(useprint_cost),"]");
				break;
			case 3://ammo
				usestring = strcat("Hold ",usebutton, " to buy ammo for ", GetWeaponName(useprint_weapon), " [Cost:", ftos(useprint_cost),"]");
				break;
			case 4://weapon
				usestring = strcat("Hold ",usebutton, " to buy ", GetWeaponName(useprint_weapon), " [Cost:", ftos(useprint_cost),"]");
				break;
			case 5://window
				usestring = strcat("Hold ",usebutton, " to Rebuild Barrier");
				break;
			case 6://box
				usestring = strcat("Hold ",usebutton, " to buy a random weapon [Cost:", ftos(useprint_cost),"]");
				break;
			case 7://box take
				usestring = strcat("Hold ",usebutton, " to take weapon");
				break;
			case 8://power
				usestring = "The power must be activated first";
				break;
			case 9://perk
				usestring = strcat("Hold ",usebutton, " to buy ", GetPerkName(useprint_weapon), " [Cost:", ftos(useprint_cost),"]");
				break;
			case 10://turn on power
				usestring = strcat("Hold ",usebutton, " to turn on the power");
				break;
			case 11://turn on trap
				usestring = strcat("Hold ",usebutton, " to active the electric barrier [Cost:", ftos(useprint_cost), "]");
				break;
			case 12://packapunch
				usestring = strcat("Hold ",usebutton, " to Pack a Punch [Cost:", ftos(useprint_cost), "]");
				break;
			case 13://revive
				usestring = strcat("Hold ",usebutton, " to revive player");
				break;
			default:
				usestring = "This should not happen you dum fuck";
				break;
		}
			print_width = stringwidth (usestring, 0, [0.015*width, 0.015*width, 0]);
			x = (width - print_width)/2;
			drawstring([x, 0.67*height, 0], usestring, [0.015*width, 0.015*width, 0], [1, 1, 1], 1, 1);

}

/*******************
*    HUD_Perks     *
*******************/

int perk_order[9];
int current_perk_order;
	
void(float width, float height) HUD_Perks =
{
	
	int i, s;
	int y = height - 100 - 22/*sb_round[1]->height - 22 //(round height minus perk icon height)*/;	

	//drawstring([0.01*width, 0.10*height, 0], ftos(perks), [0.03*width, 0.03*width, 0], [1, 1, 1], 1, 1);
			
	for (i = 0; i < 8; i = i + 1)
	{
		if (perk_order[i])
		{
			if (perk_order[i] == P_JUG)
			{
				drawpic([2,y,0], "gfx/hud/jug.tga", [20, 20, 1], [1,1,1], 1);
				y = y - 22;
			}
			else if (perk_order[i] == P_DOUBLE)
			{
				drawpic([2,y,0], "gfx/hud/double.tga", [20, 20, 1], [1,1,1], 1);
				y = y - 22;
			}
			else if (perk_order[i] == P_SPEED)
			{
				drawpic([2,y,0], "gfx/hud/speed.tga", [20, 20, 1], [1,1,1], 1);
				y = y - 22;
			}
			else if (perk_order[i] == P_REVIVE)
			{
				drawpic([2,y,0], "gfx/hud/revive.tga", [20, 20, 1], [1,1,1], 1);
				y = y - 22;
			}
			else if (perk_order[i] == P_FLOP)
			{
				drawpic([2,y,0], "gfx/hud/flopper.tga", [20, 20, 1], [1,1,1], 1);
				y = y - 22;
			}
			else if (perk_order[i] == P_STAMIN)
			{
				drawpic([2,y,0], "gfx/hud/stamin.tga", [20, 20, 1], [1,1,1], 1);
				y = y - 22;
			}
		}
	}
}

/*******************
*    HUD Weapons   *
*******************/

void(float width, float height) HUD_Weaponstring =
{
	string weaponstring; 
	float ws_offset;
	
	weaponstring = GetWeaponName(getstatf(STAT_ACTIVEWEAPON));
	ws_offset = (strlen(weaponstring));
		
	drawstring([0.925*width + (40*width/1024) - ws_offset*20*width/1024, 0.75*height + 10, 0], weaponstring, [0.02*width, 0.02*width, 0], [1, 1, 1], 1, 1);
}

/*******************
* HUD Progress Bar *
*******************/

void(float width, float height) HUD_Progressbar =
{
	float percent = getstatf(STAT_PROGRESSBAR);
	if (!percent) {
		return;
	}

	string progress; 
	local float ws_offset;
	
	progress = ftos(percent);
	ws_offset = (strlen(progress) - 1);

	float bar_width = 0.0175*width * 20;
	float bar_height = 0.0175*width;
	float bar_x = (width - bar_width)/2;
	float bar_y = height*0.75;

	drawfill ([bar_x - 1, bar_y - 1, 0], [bar_width+2, bar_height, 0], [0, 0, 0], 0.4);
	drawfill ([bar_x, bar_y, 0], [bar_width * percent, bar_height-2, 0], [1, 1, 1], 0.4);
	
	drawstring([(width - (88))/2, height*0.77 + 10, 0], "Reviving...", [0.0175*width, 0.0175*width, 0], [1, 1, 1], 1, 1); 
}

/*******************
*    HUD Hitmark   *
*******************/

void() HUD_Hitmark =
{
	drawpic([g_width/2 - (8/480)*g_width, g_height/2 - (8/480)*g_width,0], "gfx/hud/hit_marker.tga", [(16/480)*g_width, (16/480)*g_width, 1], [1,1,1], 1);
}

/*******************
*   HUD Crosshair  *
*******************/

float croshhairmoving; // naievil --used t o see if we are moving or not
float cur_spread;
float crosshair_offset_step;

void() Draw_Crosshair =
{
	if (K_BACKDOWN || K_FORWARDDOWN || K_LEFTDOWN || K_RIGHTDOWN) {
		croshhairmoving = 1;
		
		if (cur_spread >= CrossHairMaxSpread(getstatf(STAT_ACTIVEWEAPON))) {
			cur_spread = CrossHairMaxSpread(getstatf(STAT_ACTIVEWEAPON));
		} else {
			cur_spread += 0.5;
		}	
	} else {
		croshhairmoving = 0;
		
		if (cur_spread > 0)
			cur_spread -= 0.5;
		else 
			cur_spread = 0;
	}	

	if (getstatf(STAT_WEAPONZOOM) == 2 && zoom_2_time < time)
    {
		setmodel(vmodel, "");
		setmodel(v2model, "");
		drawfill('0 0 0',  [g_width/2 - g_height/2, g_height, 0], '0 0 0', 1);
		drawpic([(g_width/2 - g_height/2),0,0], "gfx/hud/scope.tga", [g_height, g_height, 1], [1,1,1], 1);
		drawfill([(g_width/2 + g_height/2),0,0],  [g_width, g_height, 0], '0 0 0', 1);
	}
    
	if (getstatf(STAT_HEALTH) < 11)
		return;
		
	if (crosshair_spread_time > time && crosshair_spread_time)
    {
        cur_spread = cur_spread + 10;
		if (cur_spread >= CrossHairMaxSpread(getstatf(STAT_ACTIVEWEAPON)))
			cur_spread = CrossHairMaxSpread(getstatf(STAT_ACTIVEWEAPON));
		
		if (!croshhairmoving)
			cur_spread *= 1/2;
    }
    else if (crosshair_spread_time < time && crosshair_spread_time)
    {
        cur_spread = cur_spread - 0.25;
		if (cur_spread <= 0)
		{
			cur_spread = 0;
			crosshair_spread_time = 0;
		}
    }

	if (getstatf(STAT_ACTIVEWEAPON) == W_M2)
	{
		drawstring([(g_width/2 - g_width*0.0175/2), (g_height/2 - g_height*0.0175/2), 0], "O", [0.0175*g_width, 0.0175*g_width, 0], [1, 1, 1], 1, 1);
	}
	else if (/*crosshair.value == 1 && */getstatf(STAT_WEAPONZOOM) != 1 && getstatf(STAT_WEAPONZOOM) != 2 && getstatf(STAT_ACTIVEWEAPON) != W_PANZER) // naievil (FIXME) crosshair cvar
    {
        int x_value, y_value;
        int crosshair_offset; /*= CrossHairWeapon() + cur_spread;*/
        
        /*if (sv_player->v.view_ofs[2] != 32) // naievil -- changed weapon spread if crouched or not
         crosshair_offset = CrossHairWeapon()*(.8) + cur_spread;
        else*/
         crosshair_offset = CrossHairWeapon(getstatf(STAT_ACTIVEWEAPON)) + cur_spread;
        
		if (CrossHairMaxSpread(getstatf(STAT_ACTIVEWEAPON)) < crosshair_offset)
			crosshair_offset = CrossHairMaxSpread(getstatf(STAT_ACTIVEWEAPON));

		crosshair_offset_step += (crosshair_offset - crosshair_offset_step) * 0.5;

		x_value = ((480 - 8)/2 - crosshair_offset_step)*(g_width/480);
		y_value = ((272 - 8)/2)*g_height/272;
		drawstring([x_value, y_value, 0], "-", [0.0175*g_width, 0.0175*g_width, 0], [1, 1, 1], 1, 1); 

		x_value = ((480 - 8)/2 + crosshair_offset_step)*(g_width/480);
		y_value = ((272 - 8)/2)*g_height/272;
		drawstring([x_value, y_value, 0], "-", [0.0175*g_width, 0.0175*g_width, 0], [1, 1, 1], 1, 1); 

		x_value = ((480 - 8)/2)*(g_width/480);
		y_value = ((272 - 8)/2 - crosshair_offset_step)*g_height/272;
		drawstring([x_value, y_value, 0], "|", [0.0175*g_width, 0.0175*g_width, 0], [1, 1, 1], 1, 1); 

		x_value = ((480 - 8)/2)*(g_width/480);
		y_value = ((272 - 8)/2 + crosshair_offset_step)*g_height/272;
		drawstring([x_value, y_value, 0], "|", [0.0175*g_width, 0.0175*g_width, 0], [1, 1, 1], 1, 1); 

    }
    else if (/*crosshair.value && */getstatf(STAT_WEAPONZOOM) != 1 && getstatf(STAT_WEAPONZOOM) != 2) // naievil (FIXME) crosshair cvar
		drawstring([((480 - 8)/2/480)*g_width, ((272 - 8)/2)*(g_height/272), 0], ".", [0.0175*g_width, 0.0175*g_width, 0], [1, 1, 1], 1, 1); 
}

void() HUD_Powerups = {

	if(getstatf(STAT_X2))
		drawpic([(g_width/2 - (28/272)*g_height),0,0], "gfx/hud/2x.tga", [(28/272)*g_height, (28/272)*g_height, 1], [1,1,1], 1);
	if(getstatf(STAT_INSTA))
		drawpic([(g_width/2 + (5/480)*g_width),0,0], "gfx/hud/in_kill.tga", [(28/272)*g_height, (28/272)*g_height, 1], [1,1,1], 1);
}

void() HUD_Broadcast = {

	string broadcast_msg = "";
	float health = getstatf(STAT_HEALTH);
	
		switch(broadcast_type) {
			case 2: broadcast_msg = "A Player needs to be revived"; break;
			default: broadcast_msg = "benis"; break;
		}
	float print_width = stringwidth (broadcast_msg, 0, [0.015*g_width, 0.015*g_width, 0]);
	float x = (g_width - print_width)/2;
	if (broadcast_type == 2 && health > 19)
		drawstring([x, g_height/2, 0], broadcast_msg, [0.015*g_width, 0.015*g_width, 0], [1, 1, 1], 1, 1);
}

void() HUD_Scores =
{
	string subtext = "Name                Kills        Score";
	float xback, i, x;
	vector TEXTCOLOR = [1, 1, 1];
	
	if(serverkey("constate") != "disconnected")
	{
		float print_width = stringwidth(subtext, 0, [0.015*g_width, 0.015*g_width, 0]);
		x = (g_width - print_width)/2;
		drawstring([x,g_height*(5/12), 0], subtext, [0.015*g_width, 0.015*g_width, 0], [1, 1, 1], 1, 1);
	
		xback = x;
	
		for (i = 0; i < 4; i = i + 1)
		{
			if (playerpoints[i] == -1)
				break;
			
			switch(i) {
				case 1: TEXTCOLOR = TEXT_LIGHTBLUE; break;
				case 2: TEXTCOLOR = TEXT_ORANGE; break;
				case 3: TEXTCOLOR = TEXT_GREEN; break;
				default: TEXTCOLOR = [1, 1, 1]; break;
			}
			
			print_width = stringwidth(ftos(playerpoints[i]), 0, [0.015*g_width, 0.015*g_width, 0]);
			x = (g_width + (0.5*g_width) - print_width)/2;
			drawstring([x,g_height*(5.75/12)+(i*g_width*0.03), 0], ftos(playerpoints[i]), [0.015*g_width, 0.015*g_width, 0], TEXTCOLOR, 1, 1);
			drawstring([x/1.36,g_height*(5.75/12)+(i*g_width*0.03), 0], ftos(playerkills[i]), [0.015*g_width, 0.015*g_width, 0], TEXTCOLOR, 1, 1); 
			drawstring([xback,g_height*(5.75/12)+(i*g_width*0.03), 0], playernames[i], [0.015*g_width, 0.015*g_width, 0], TEXTCOLOR, 1, 1); 
		}
	}
}

void() HUD_Endgame = {

	string message = "GAME OVER";
	string survive = strcat("You survived ",ftos(rounds)," rounds");
	
	// first message
	float print_width = stringwidth(message, 0, [(1/30)*g_width, (1/30)*g_width, 0]);
	float x = (g_width - print_width)/2;
	drawstring([x, g_height*(1/4), 0], message, [(1/30)*g_width, (1/30)*g_width, 0], [1, 1, 1], 1, 1);

	// second message
	print_width = stringwidth(survive, 0, [0.025*g_width, 0.025*g_width, 0]);
	x = (g_width - print_width)/2;
	drawstring([x,g_height*(1/3), 0], survive, [0.025*g_width, 0.025*g_width, 0], [1, 1, 1], 1, 1);
	
	// we can reuse our tab scores for the endgame
	HUD_Scores();
}

float oldfade_alpha;
void() HUD_Fade = 
{  
	float alpha;
	
	if (fade_type == 1) {
		alpha = cos(fade_time - time);
			if (oldfade_alpha > 0.95)
			alpha = 1;
			
			alpha = invertfloat(alpha);
						
		drawfill ([0, 0, 0], [g_width, g_height, 0], [0, 0, 0], alpha);	// background
		oldfade_alpha = alpha;
	}
	else if (fade_type == 2) {
		alpha = sin(((fade_time - time) * 2));
		if (oldfade_alpha > 0.95)
			alpha = 1;
				
		drawfill ([0, 0, 0], [g_width, g_height, 0], [0, 0, 0], alpha);	// background
		oldfade_alpha = alpha;
	}
}

void(float width, float height) HUD_ScrollText = {
	local float print_width = stringwidth (scrolltext, 0, [0.015*width, 0.015*width, 0]);
	local float x = (width - print_width)/2;

	drawstring([x, scrollheight*height, 0], scrolltext, [0.015*width, 0.015*width, 0], [1, 1, 1], scrollopacity, 1); //low
	if (scrollheight > 0.70) {
		scrollheight -= 0.0002;
		if (scrollopacity > 0)
			scrollopacity -= 0.002;
	} else {
		stext = 0;
	}
}

/*******************
*     HUD Draw     *
*******************/

void(float width, float height) HUD_Draw = 
{
	if (!getstatf(STAT_SPECTATING) && (getstatf(STAT_HEALTH) > 10) && !score_show)
	{
		Draw_Crosshair();
		HUD_Health(width, height);
		HUD_Points(width, height);
		HUD_Rounds(width, height);
		HUD_Perks(width, height);
		HUD_Progressbar(width, height);
		HUD_Powerups();
		HUD_AmmoString();
	
		if (HUD_Change_time > time)
		{
			HUD_Ammo(width, height);
			HUD_Grenades(width, height);
			HUD_Weaponstring(width, height);
		}
			
		if (useprint_time > time) 
			HUD_Useprint(width, height);
		
		if (Hitmark_time > time)
			HUD_Hitmark();

		if (stext) {
			HUD_ScrollText(width, height);
		} else {
			scrollopacity = 1;
			scrollheight = 0.80;
		}
	}
	
	// Only keep broadcast messages outside in case they are important
	if (broadcast_time > time)
		HUD_Broadcast();
	
	if (getstatf(STAT_HEALTH) <= 10 && getstatf(STAT_SPECTATING) && !find(world, classname, "ai_zombie"))
		HUD_Endgame();
		
	if (score_show)
		HUD_Scores();
		
	if (fade_time > time)
		HUD_Fade();
}

void UpdatePerks (float newperks) {
	float s;
	if (newperks & P_JUG && !(perks & P_JUG))
	{
		perk_order[current_perk_order] = P_JUG;
		current_perk_order = current_perk_order + 1;
	}
	if (newperks & P_DOUBLE && !(perks & P_DOUBLE))
	{
		perk_order[current_perk_order] = P_DOUBLE;
		current_perk_order = current_perk_order + 1;
	}
	if (newperks & P_SPEED && !(perks & P_SPEED))
	{
		perk_order[current_perk_order] = P_SPEED;
		current_perk_order = current_perk_order + 1;
	}
	if (newperks & P_REVIVE && !(perks & P_REVIVE))
	{
		perk_order[current_perk_order] = P_REVIVE;
		current_perk_order = current_perk_order + 1;
	}
	if (newperks & P_FLOP && !(perks & P_FLOP))
	{
		perk_order[current_perk_order] = P_FLOP;
		current_perk_order = current_perk_order + 1;
	}
	if (newperks & P_STAMIN && !(perks & P_STAMIN))
	{
		perk_order[current_perk_order] = P_STAMIN;
		current_perk_order = current_perk_order + 1;
	}
	if (perks & P_JUG && !(newperks & P_JUG))
	{
		for (s = 0; s < 8; s++)
		{
			if (perk_order[s] == P_JUG)
			{
				perk_order[s] = 0;
				while (perk_order[s+1])
				{
					perk_order[s] = perk_order[s+1];
					perk_order[s+1] = 0;
				}
				break;
			}
		}
		current_perk_order = current_perk_order - 1;
	}
	if (perks & P_DOUBLE && !(newperks & P_DOUBLE))
	{
		for (s = 0; s < 8; s++)
		{
			if (perk_order[s] == P_DOUBLE)
			{
				perk_order[s] = 0;
				while (perk_order[s+1])
				{
					perk_order[s] = perk_order[s+1];
					perk_order[s+1] = 0;
				}
				break;
			}
		}
		current_perk_order = current_perk_order - 1;
	}
	if (perks & P_SPEED && !(newperks & P_SPEED))
	{
		for (s = 0; s < 8; s++)
		{
			if (perk_order[s] == P_SPEED)
			{
				perk_order[s] = 0;
				while (perk_order[s+1])
				{
					perk_order[s] = perk_order[s+1];
					perk_order[s+1] = 0;
				}
				break;
			}
		}
		current_perk_order = current_perk_order - 1;
	}
	if (perks & P_REVIVE && !(newperks & P_REVIVE))
	{
		for (s = 0; s < 8; s++)
		{
			if (perk_order[s] == P_REVIVE)
			{
				perk_order[s] = 0;
				while (perk_order[s+1])
				{
					perk_order[s] = perk_order[s+1];
					perk_order[s+1] = 0;
				}
				break;
			}
		}
		current_perk_order = current_perk_order - 1;
	}
	if (perks & P_FLOP && !(newperks & P_FLOP))
	{
		for (s = 0; s < 8; s++)
		{
			if (perk_order[s] == P_FLOP)
			{
				perk_order[s] = 0;
				while (perk_order[s+1])
				{
					perk_order[s] = perk_order[s+1];
					perk_order[s+1] = 0;
				}
				break;
			}
		}
		current_perk_order = current_perk_order - 1;
	}
	if (perks & P_STAMIN && !(newperks & P_STAMIN))
	{
		for (s = 0; s < 8; s++)
		{
			if (perk_order[s] == P_STAMIN)
			{
				perk_order[s] = 0;
				while (perk_order[s+1])
				{
					perk_order[s] = perk_order[s+1];
					perk_order[s+1] = 0;
				}
				break;
			}
		}
		current_perk_order = current_perk_order - 1;
	}
	
	perks = newperks;
}