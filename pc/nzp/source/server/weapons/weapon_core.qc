void(string to) UpdateV2model;

void() ReturnWeaponModel =
{
	self.weaponmodel = GetWeaponModel(self.weapon, 0);
	if (self.weapon == W_KAR_SCOPE || self.weapon == W_HEADCRACKER)
		self.weapon2model = "progs/VModels/v_karscope.mdl";
		
	UpdateV2model(self.weapon2model);
}

void() sprintstop =
{
	float startframe;
	float endframe;
	string modelname;
	startframe = GetFrame(self.weapon,SPRINT_OUT_START);
	endframe = GetFrame(self.weapon,SPRINT_OUT_END);
	modelname = GetWeaponModel(self.weapon, 0);
	Set_W_Frame (startframe, endframe, 0, 0, SPRINT, /*ContinueRun*/ SUB_Null, modelname, false);//FIXME
	self.zoom = 0;
	self.into_sprint = 0;
	/*self.reload_delay2 = self.fire_delay2 = */self.reload_delay = self.fire_delay = 0;
	yeahIamrunning = false;
}

void(float to) SwitchWeapon =
{
	
	WriteByte(MSG_MULTICAST, SVC_CGAMEPACKET);
	WriteByte(MSG_MULTICAST, EVENT_WEAPONCHANGE);
	WriteByte(MSG_MULTICAST, to);
	msg_entity = self;
	multicast('0 0 0', MULTICAST_ONE);
	
}

void() W_Switch =
{
	if (self.secondaryweapon && self.secondaryweapon !=0 && !self.new_anim_stop && !other.button7)
	{      
		float tempf,tempf1,tempf2;
		float startframe;
		float endframe;
		string modelname;
			
		tempf = self.currentammo;
		self.currentammo = self.secondaryammo;
		self.secondaryammo = tempf;

		tempf1 = self.currentmag;
		self.currentmag = self.secondarymag;
		self.secondarymag = tempf1;

		tempf2 = self.weapon;
		self.weapon = self.secondaryweapon;
		self.secondaryweapon = tempf2;

		startframe = GetFrame(self.weapon,TAKE_OUT_START);
		endframe = GetFrame(self.weapon,TAKE_OUT_END);
		modelname = GetWeaponModel(self.weapon, 0);

		SwitchWeapon(self.weapon);
		
		/*if ((self.weapon == W_DB && self.secondaryweapon == W_SAWNOFF) || (self.weapon == W_SAWNOFF && self.secondaryweapon == W_DB))
      self.currentammo = self.secondaryammo;*/
		
		//UpdateWeapons(1);
		//if (self.weaponslot1.dualwield)
		//	Set_W2_Frame (self.weaponslot1.TakeWeaponStart, self.weaponslot1.TakeWeaponEnd, 0, 0, 0, SUB_Null, self.weaponslot1.v_model2, false);//FIXME
		Set_W_Frame (startframe, endframe, 0, 0, 0, SUB_Null, modelname, false);//FIXME
		
		/*self.reload_delay2 = self.fire_delay2 = */self.reload_delay = self.fire_delay = 0;
	}
}

void() W_PutOut =
{		
	if (self.secondaryweapon && !self.new_anim_stop)
	{
		float startframe;
		float endframe;
		string modelname;
		startframe = GetFrame(self.weapon,PUT_OUT_START);
		endframe = GetFrame(self.weapon,PUT_OUT_END);
		modelname = GetWeaponModel(self.weapon, 0);
	
		//UpdateWeapons(1);
		//if (self.weaponslot1.dualwield)
		//	Set_W2_Frame (self.weaponslot1.PutOutStart, self.weaponslot1.PutOutEnd, (self.weaponslot1.PutOutEnd - self.weaponslot1.PutOutStart)/10, 0, SWITCHWEP, W_Switch, self.weaponslot1.v_model2, false);//FIXME
		Set_W_Frame (startframe, endframe, (endframe - startframe)/10, 0, SWITCHWEP, W_Switch, modelname, false);//FIXME
		/*self.reload_delay2 = self.fire_delay2 = */self.reload_delay = self.fire_delay = 0;
	}
}


//RELOAD

void() W_Give_Ammo =
{
	float ammo_shot, max_mag;
	
	max_mag = getWeaponMag(self.weapon);

	ammo_shot = max_mag - self.currentmag;
	if (ammo_shot < self.currentammo)
	{
    	self.currentammo = self.currentammo - ammo_shot;
      
		self.currentmag = max_mag;
	}
	else
	{
		self.currentmag = self.currentmag + self.currentammo;
		self.currentammo = 0;
	}
	//UpdateWeapons(0);
};

void () W_LoadAmmo;
void() ContinueReload = //Special reloads
{
	float delay;
	if (self.new_anim_stop)
		return;
	string modelname;
	modelname = GetWeaponModel(self.weapon, 0);
	
	if (self.weapon == W_GUT && self.currentmag == 10)
    return;
	
	if (self.currentmag >= getWeaponMag(self.weapon) || !self.currentammo || self.reloadinterupted) {
		if (self.weapon == W_KAR_SCOPE || self.weapon == W_HEADCRACKER)
		{
			delay = 1; 
			self.reload_delay = time + delay;
			Set_W_Frame (24, 28, delay, 0, RELOAD, SUB_Null, modelname, false);
		} else if (self.weapon == W_TRENCH || self.weapon == W_GUT) {
			delay = 0.5; 
			self.reload_delay = time + delay;
			Set_W_Frame (24, 26, delay, 0, RELOAD, W_LoadAmmo, modelname, false);
		}
		self.reloadinterupted = FALSE;
	} else if (self.currentmag < getWeaponMag(self.weapon)) {
		if (self.weapon == W_BROWNING || self.weapon == W_ACCELERATOR) {
			delay = 4; 
			self.reload_delay = time + delay;
			Set_W_Frame (45, 77, delay, 50, RELOAD, W_Give_Ammo, modelname, false);
		} else if (self.weapon == W_KAR_SCOPE || self.weapon == W_HEADCRACKER) {
			self.currentmag++;
        	self.currentammo = self.currentammo - 1;
			delay = 0.8; 
			self.reload_delay = time + delay;
			Set_W_Frame (19, 24, delay, 0, RELOAD, ContinueReload, modelname, false);
		} else if (self.weapon == W_TRENCH) {
			self.currentmag++;
        	self.currentammo = self.currentammo - 1;
			delay = 0.5; 
			self.reload_delay = time + delay;
			Set_W_Frame (18, 23, delay, 0, RELOAD, ContinueReload, modelname, false);
		}
	}
}

void() W_Reload =
{
	//blubs remove me, for testing rendering zombie models=============
	/*
	local entity z;
	z = find(world,classname,"test_zombie");
	while(z)
	{
		remove(z);
		z = find(z,classname,"test_zombie");
	}*/
	//==============================================================
	if (self.reload_delay > time || self.new_anim_stop || self.currentmag >= getWeaponMag(self.weapon))
		return;

	float endframe, startframe, reloadcancelframe;
	string modelname;
	modelname = GetWeaponModel(self.weapon, 0);
	
	if (self.currentammo)
	{
		startframe = GetFrame(self.weapon,RELOAD_START);
		endframe = GetFrame(self.weapon,RELOAD_END);
		reloadcancelframe = GetFrame(self.weapon,RELOAD_CANCEL);

		if (self.weapon == W_BROWNING || self.weapon ==  W_ACCELERATOR) {
			if (!self.currentmag) {
				Set_W_Frame (26, 77, 0, 45, RELOAD, W_Give_Ammo, modelname, false);
				self.reload_delay = 6 + time;
			} else if (self.currentmag > 0) {
				Set_W_Frame (4, 25, 0, 0, RELOAD, ContinueReload, modelname, false);
				self.reload_delay = 3.5 + time;
			}
		} else if (self.weapon == W_KAR_SCOPE || self.weapon == W_HEADCRACKER ){
			Set_W_Frame (14, 18, 0, 0, RELOAD, ContinueReload, modelname, false);
			self.reload_delay = 0.8 + time;
		} else if (self.weapon == W_M1 || self.weapon == W_M1000) {
			if (self.currentmag > 0) {
				Set_W_Frame (4, 44, 0, 25, RELOAD, W_Give_Ammo, modelname, false);
				self.reload_delay = 3.9;
			} else {
				Set_W_Frame (8, 44, 0, 25, RELOAD, W_Give_Ammo, modelname, false);
				self.reload_delay = 3.6;
			}
		} else if (self.weapon == W_TRENCH || self.weapon == W_GUT) {
			if (self.currentmag == 0)
				self.NeedLoad = true;
			Set_W_Frame (14, 17, 0, 0, RELOAD, ContinueReload, modelname, false);
			self.reload_delay = 0.8;
		} else {
			Set_W_Frame (startframe, endframe, 0, reloadcancelframe, RELOAD, W_Give_Ammo, modelname, TRUE);
			self.reload_delay = getWeaponDelay(self.weapon,RELOAD);
			self.reload_delay = self.reload_delay + time;
		}
	}
	
	if (self.weapon != W_TRENCH) {
		self.NeedLoad = false;
	}
};

void () W_LoadAmmoDone =
{
	self.NeedLoad = false;
}
void () W_LoadAmmo =
{
	string modelname;
	if (!self.NeedLoad)
		return;
	if (!self.currentmag)
	{
		W_Reload();
		return;
	}

	modelname = GetWeaponModel(self.weapon, 0);

	if (self.weapon == W_TRENCH || self.weapon == W_GUT)
	{
		Set_W_Frame (4, 14, 0, 12, FIRE, W_LoadAmmoDone, modelname, false);
		self.fire_delay = 1 + time;
	}
	else if (self.weapon == W_KAR || self.weapon == W_ARMAGEDDON || self.weapon == W_KAR_SCOPE || self.weapon == W_HEADCRACKER)
	{
		Set_W_Frame (4, 13, 1.1, 9, FIRE, W_LoadAmmoDone, modelname, false);
		self.fire_delay = 0.9 + time;
	}	
}

void () CheckReload = 
{
	if (!self.currentmag) {
		W_Reload();
	}
}


void Parse_Damage () = // DO NOT TOUCH
{
	entity ent;
	float total_dmg;
	ent = findfloat (world, washit, 1);

	while (ent) {
		if (ent.classname == "ai_zombie") {
			total_dmg = ent.hitamount;
			//Clear hit
			ent.washit = 0;
			ent.hitamount = 0;

			
			DamageHandler(ent,self, total_dmg, S_NORMAL);
		}
		ent = findfloat (ent, washit, 1);
	}
}

void(float damage, vector dir, vector org, vector plane, entity hit_ent) TraceAttack =
{
	vector  vel;
	float f_damage;
  
	vel = normalize(dir);
	vel = vel + 2*plane;
	vel = vel * 200;

	if (hit_ent.takedamage) {
		if (trace_fraction >= 1) {
			return;
		}

		f_damage = damage;

		hit_ent.washit = 1;
		hit_ent.hitamount = hit_ent.hitamount + f_damage;
	}

	WriteByte(MSG_MULTICAST, SVC_CGAMEPACKET);
	WriteByte(MSG_MULTICAST, EVENT_PISTOLFIRE);
	WriteEntity(MSG_MULTICAST, self);
	WriteCoord(MSG_MULTICAST, org_x);
	WriteCoord(MSG_MULTICAST, org_y);
	WriteCoord(MSG_MULTICAST, org_z);
	WriteCoord(MSG_MULTICAST, plane_x);
	WriteCoord(MSG_MULTICAST, plane_y);
	WriteCoord(MSG_MULTICAST, plane_z);
	WriteEntity(MSG_MULTICAST, hit_ent);
	multicast(trace_endpos, MULTICAST_PHS);
};

void (float shotcount, float sprd, float Damage/*, float headmulti, float legmulti*/) FireTrace =
{
	float count, r, ru, penetration_times;
	vector dir, src, trace_start_org;
	entity hitent;
	
	makevectors(self.v_angle);
	
	src = self.origin + self.view_ofs;

	while (count < shotcount)
	{
		dir = aim (self,0);
		r = random() * sprd*10;
		if (random() < 0.5)
			r = r*-1;
		ru = random() * sprd*10;
		if (random() < 0.5)
			ru = ru*-1;

		dir = dir*2048;
		dir = dir + v_right*r + v_up*ru;
		trace_start_org = src;
		penetration_times = 0;
		trace_ent = self;
		while (random() < getWeaponPenetration(self.weapon, penetration_times))
		{
			traceline (trace_start_org, trace_start_org + dir, 0, trace_ent);
			
			if (trace_ent == world) {
				break;
			}
			
			if (trace_fraction != 1.0) {
				TraceAttack (Damage, dir, trace_endpos, trace_plane_normal, trace_ent);
			}
			trace_start_org = trace_endpos;
			penetration_times++;
			if (!trace_ent.takedamage) {
				break;
			}
		}

		count++;
	}
	Parse_Damage();

}


void() W_Fire =
{
	//First check that we can actualy fire
	if (time < self.fire_delay || self.new_anim_stop || self.reload_delay > time || self.weapon == 0)
		return;

	float startframe;
	float endframe;
	float firetype;
	float damage;
	float shotcount;
	string modelname;
	string soundname;
	float spread;
	float delay;

	//Update the basic vectors
	makevectors(self.v_angle);

	//make sure magazine is loading
	if (!self.currentmag)
	{
		W_Reload();
		return;
	}

	//Dont fire if the gun has to cycle
	if (self.NeedLoad && (self.weapon == W_TRENCH || self.weapon == W_GUT || self.weapon == W_KAR_SCOPE || self.weapon == W_KAR || self.weapon == W_ARMAGEDDON || self.weapon == W_HEADCRACKER))
	{
		W_LoadAmmo();
		return;
	}
	
	//get some basic info
	damage = getWeaponDamage(self.weapon);   
	firetype = GetFiretype (self.weapon);
	modelname = GetWeaponModel(self.weapon, 0);
	shotcount = GetWeaponShotcount(self.weapon);
    soundname = GetWeaponSound(self.weapon);
	delay = getWeaponDelay(self.weapon, FIRE);
	spread = GetWeaponSpread(self.weapon);


	//Fire weapons
	if (firetype == 1)
	{
		if (self.semi)
			return;
		
		self.semi = TRUE;
	}

	FireTrace(shotcount, spread, damage/* , self.weaponslot1.headx, self.weaponslot1.legx */);


	//Play weapon animation and sound
	startframe = GetFrame(self.weapon,FIRE_START);
	endframe = GetFrame(self.weapon,FIRE_END);
	if (self.weapon == W_GUT || self.weapon == W_KAR_SCOPE || self.weapon == W_TRENCH || self.weapon == W_KAR || self.weapon == W_ARMAGEDDON || self.weapon == W_HEADCRACKER)
	{
		Set_W_Frame (startframe, endframe, delay, 0, FIRE, W_LoadAmmo, modelname, FALSE);
		self.NeedLoad = true;
	} else {
		Set_W_Frame (startframe, endframe, delay, 0, FIRE, CheckReload, modelname, FALSE);
	}


	sound (self, CHAN_WEAPON, soundname, 1, ATTN_NORM);

	self.currentmag = self.currentmag - 1;
	self.fire_delay = getWeaponDelay(self.weapon, FIRE) + time;
}
/******************************
* W_Grenade                   *
******************************/

void() switch_nade = 
{ 
    if (isBuying == true)
		return;
      
    if (!(self.grenades & 2))
		return;
      
    if (self.semiswitch == true)
      return;
/*		tempf = self.primary_grenades;
		self.primary_grenades = self.secondary_grenades;
		self.secondary_grenades = tempf;*/

	if (self.pri_grenade_state == 0)
	{
		centerprint (self, "Bouncing Betties Selected");
		self.bk_nade = 1;
    }
    if (self.pri_grenade_state == 1)
    {
		centerprint (self, "Frag Grenades Selected");
		self.bk_nade = 0;
    }  	
		
		self.pri_grenade_state = self.bk_nade;

};

void() GrenadeExplode =
{
	/*DamgageExplode (self, self.owner, 225, 75, 128);//was 256 inch radius, kicked it down to 128 because 21 feet exploding radius is... a bit overkill...
	
	WriteByte (MSG_BROADCAST, SVC_TEMPENTITY);
	WriteByte (MSG_BROADCAST, TE_EXPLOSION);
	WriteCoord (MSG_BROADCAST, self.origin_x);
	WriteCoord (MSG_BROADCAST, self.origin_y);
	WriteCoord (MSG_BROADCAST, self.origin_z);*/ 	// naievil (FIXME) Everything

	SUB_Remove ();
};
void() NadeStraighten =
{
	self.angles_x = (self.angles_x > 0) ? 90 : -90;	
	
	if (self.pri_grenade_state == 1)
    return;
};
void() Velocity_reduce =
{
	if (!other.solid || other.solid == SOLID_TRIGGER)
		if (other != world)
			return;

	self.velocity = self.velocity*0.5;
	
	NadeStraighten();
};

void() betty_touch = 
{
  //centerprint (other, "wow\n");
  if (other == self.owner || other.solid == SOLID_TRIGGER)
    if (other != world)
      return;
  
  GrenadeExplode();
}

void() W_ThrowGrenade =
{
	string modelname;
	float startframe;
	float endframe;
	local	entity nade;
	local entity betty;
	
if (self.pri_grenade_state == 0)
{
	nade = spawn ();
	nade.owner = self;
	nade.grenade_delay = nade.owner.grenade_delay;
	nade.owner.grenade_delay = 0;
	nade.movetype = MOVETYPE_BOUNCE;
	nade.solid = SOLID_BBOX;
	nade.classname = "grenade";
		
// set nade speed	

	makevectors (self.v_angle);

	nade.velocity = v_forward*800;

	nade.avelocity = '400 -400 400';

	//nade.angles = vectoangles(nade.velocity);
	//nade.angles_z += (nade.angles_z + 180 < 360)? 180 : -180;
	nade.angles = vectoangles(v_forward);
	nade.angles_z -= 35;
// set nade duration
	nade.nextthink = nade.grenade_delay;
	nade.think = GrenadeExplode;

	nade.touch = Velocity_reduce;
	setmodel (nade, "progs/GModels/g_grenade.mdl");
	setsize (nade, '0 0 0', '0 0 0');
	nade.origin = self.origin + self.view_ofs;
	nade.origin += v_forward * 12;
	setorigin (nade, nade.origin);
	
	self.animend = ReturnWeaponModel;
	self.callfuncat = 0;
	isBuying = false;
 }
else if (self.pri_grenade_state == 1)
{
	if (!(self.flags & FL_ONGROUND))
	{
    self.semiswitch = false;
    centerprint (self, "You cannot place a bouncing betty here");
    self.animend = ReturnWeaponModel;
    self.callfuncat = 0;
    isBuying = false; 
  }
  if (self.flags & FL_ONGROUND)
  {
	betty = spawn ();
	betty.owner = self;
	betty.grenade_delay = betty.owner.grenade_delay;
	betty.owner.grenade_delay = 0;
	betty.movetype = MOVETYPE_NONE;
	betty.solid = SOLID_TRIGGER;
	betty.classname = "betty";
		
// set betty speed	
	betty.velocity = v_forward*0;

	//nade.angles = vectoangles(nade.velocity);
	//nade.angles_z += (nade.angles_z + 180 < 360)? 180 : -180;
// set nade duration
	betty.think = GrenadeExplode;

	betty.touch = betty_touch;
	setmodel (betty, "progs/GModels/g_betty.mdl");
	setsize (betty, '-16 -16 -4', '16 16 1');
	betty.origin = betty.owner.origin - self.view_ofs + '0 0 1';
	betty.origin += v_forward * 0;
	setorigin (betty, betty.origin);
	
	self.animend = ReturnWeaponModel;
	self.callfuncat = 0;
	isBuying = false;  
	}
 }
 else 
 {
  centerprint (other, "No grenadetype defined...\n");
 }
    if (!(self.flags & FL_ONGROUND))
      self.secondary_grenades = self.secondary_grenades + 1;
      
 		startframe = GetFrame(self.weapon,TAKE_OUT_START);
		endframe = GetFrame(self.weapon,TAKE_OUT_END);
		modelname = GetWeaponModel(self.weapon, 0);
		Set_W_Frame (startframe, endframe, 0, 0, 0, SUB_Null, modelname, false);
		self.semiswitch = false;
}

void() checkHold =
{
 if (self.pri_grenade_state == 0)
 {
	if (!self.button3 || self.grenade_delay < time)
	{
		if(self.grenade_delay < time)
			self.grenade_delay = time + 0.05;
			
		isBuying = true;  
		Set_W_Frame (3, 6, 0, 5, GRENADE, W_ThrowGrenade, "progs/VModels/v_nade.mdl", true);
		sound (self, CHAN_WEAPON, "sounds/weapons/grenade/throw.wav", 1, ATTN_NORM);
		self.reload_delay = self.fire_delay = time + 0.4;
		self.throw_delay = time + 0.9;
	}
	else
	{
    isBuying = true;
		Set_W_Frame (2, 2, 0, 0, GRENADE, checkHold, "progs/VModels/v_nade.mdl", true);
		//self.weaponframe = 12;
		//self.weapon_anim_end = 12;
		//self.animend = checkHold;
		//self.weapon_anim_type = GRENADE;
	}
 }
  else if (self.pri_grenade_state == 1)
 {    
	if (!self.button3)
	{
		if(self.grenade_delay < time)
			self.grenade_delay = time + 0.05;
		isBuying = true;
		Set_W_Frame (18, 23, 0, 5, GRENADE, W_ThrowGrenade, "progs/VModels/v_betty.mdl", true);
		sound (self, CHAN_WEAPON, "sounds/weapons/grenade/throw.wav", 1, ATTN_NORM);
		self.reload_delay = self.fire_delay = time + 0.4;
		self.throw_delay = time + 0.9;
	}
	else
	{    
		isBuying = true;
		Set_W_Frame (18, 18, 0, 0, GRENADE, checkHold, "progs/VModels/v_betty.mdl", true);
	}
 }
 else
	centerprint (other, "grenades switched up...\n");
		
}

void() W_Grenade =
{
	if (self.throw_delay > time || self.zoom || self.downed)
		return;

	if (self.primary_grenades > 0 || self.secondary_grenades > 0)
  {         
	  if (self.pri_grenade_state == 0 && self.primary_grenades > 0)
      {
		Set_W_Frame (0, 2, 0, 0, GRENADE, checkHold, "progs/VModels/v_nade.mdl", true);
		sound (self, CHAN_WEAPON, "sounds/weapons/grenade/prime.wav", 1, ATTN_NORM);	
		self.primary_grenades = self.primary_grenades - 1;
		self.throw_delay = self.reload_delay = self.fire_delay = time + 6;
		self.grenade_delay = time + 5;
		//self.holdnade = TRUE;
      }
    else if (self.pri_grenade_state == 1 && self.secondary_grenades > 0)
      {  
		Set_W_Frame (0, 18, 0, 0, GRENADE, checkHold, "progs/VModels/v_betty.mdl", true);
		sound (self, CHAN_WEAPON, "sounds/weapons/grenade/prime.wav", 1, ATTN_NORM);	
		self.secondary_grenades = self.secondary_grenades - 1;
		self.throw_delay = self.reload_delay = self.fire_delay = time + 6;
//	 	self.grenade_delay = time + 5;
      //self.holdnade = TRUE;
      }
    self.semiswitch = true;
   }    
}

void () Impulse_Functions =
{
	switch (self.impulse)
	{		
		case 22:
			entity benis;
			benis = find (world, classname, "player");
			addmoney(benis, 10000, 0);
			//crouchset();
			break;
		case 30:
			entity ent1;
			ent1 = find(world, classname, "player");
			print("Player bbox size set to zombie bbox size.\n");
			setsize(ent1, [-8,-8,-32],[8,8,30]);
			break;
		case 31:
			entity ent2;
			ent2 = find(world, classname, "player");
			print("Player bbox size restored.\n");
			setsize(ent2, VEC_HULL_MIN,VEC_HULL_MAX);
			break;
	}
	
	self.impulse = 0;
};

void() CheckImpulses =
{
	self.impulse = 0;
}

void () Weapon_Logic =
{
	W_Frame_Update ();
	Impulse_Functions();

	if (self.button0) {
		W_Fire();
	} else {
		self.semi = FALSE;
	}
	
	if (!self.button7) {
		self.semiuse = false;
	}
	
	if (self.button4 && !self.semiswitch && self.secondaryweapon && self.secondaryweapon !=0)
	{
		W_PutOut();
		self.semiswitch = true;
	} else if (!self.button4) {
		self.semiswitch = false;
	}
	
	if (self.button3 && isBuying != true && self.semiswitch != true)
	{
		W_Grenade();
		self.semiswitch = true;
	}
	else if (!self.button3)
		self.semiswitch = false;

	if (self.button5 && !self.semireload)
	{
		W_Reload();
		self.semireload = TRUE;
	}
	else if (!self.button5) {
		self.semireload = FALSE;
	}
	
	CheckImpulses();
}